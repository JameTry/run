<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8"/>
    <style>
        #con {
            width: 500px;
            margin: 0 auto;
        }

        #list {
            width: 200px;
            position: fixed;
            left: 20px;
            padding-right: 20px;
            overflow: scroll;
            height: 100vh;
        }

        #list p.active {
            background: #247cfa;
            color: white;
            padding: 2px;
            font-size: 18px;
            font-weight: 600;
        }

        #bottom {
            position: absolute;
            bottom: 20px;
        }
    </style>
</head>
<body>
<div id="list"></div>
<div id="con">
    <main></main>
    <div id="bottom">
        <p style="font-size: 14px;color: #7a7a7a">1隐藏英文 2隐藏翻译 3测试 -/=键翻页</p>
        <input type="checkbox" id="test">测试
        <a href="/english">文档</a>
    </div>
</div>

<script>
    let test = false;
    let showEnglish = true;
    let showChinese = true;
    let words = [];
    let currentIndex = Number(localStorage.getItem("i")) || 0;
    let baseLinesCount = 3;
    let speakT;
    const mainEl = document.querySelector("main");
    const listEl = document.getElementById("list");
    const testEl = document.getElementById("test");

    testEl.addEventListener("change", e => test = e.target.checked);

    class VoiceSynthesizer {
        constructor() {
            this.synthesis = window.speechSynthesis;
            this.voices = [];
            this.init();
        }

        init() {
            if (!this.isSupported()) {
                throw new Error('浏览器不支持语音合成');
            }
            this.loadVoices();
            this.synthesis.onvoiceschanged = () => this.loadVoices();
        }

        isSupported() {
            return 'speechSynthesis' in window;
        }

        loadVoices() {
            this.voices = this.synthesis.getVoices();
        }

        speak(text, options = {}) {
            const defaults = {
                lang: 'en-US',
                rate: 1,
                pitch: 1.0,
                volume: 1.0,
                voice: this.voices.find(v =>
                    v.lang.includes('en') && v.default
                ) || this.voices[0]
            };
            const utterance = new SpeechSynthesisUtterance(text);
            Object.assign(utterance, defaults, options);
            this.synthesis.cancel(); // 清空队列
            this.synthesis.speak(utterance);
            return utterance;
        }

        stop() {
            this.synthesis.cancel();
        }
    }

    const synthesizer = new VoiceSynthesizer();


    fetch("/CET4_T.json")
        .then(r => r.json())
        .then(data => {
            words = data;
            renderList();
            draw();
            focusLast();
        });

    function renderList() {
        listEl.innerHTML = words.map((w, i) => `
    <p data-i="${i}" class="${i === currentIndex ? "active" : ""}">
      ${i + 1}:${showEnglish ? w.name : w.trans.join("；")}
    </p>
  `).join("");
    }

    listEl.addEventListener("click", e => {
        if (e.target.tagName !== "P") return;
        currentIndex = Number(e.target.dataset.i);
        draw();
        renderList();
        saveIndex();
    });

    document.addEventListener("keydown", e => {
        const key = e.key;
        if (key === "=") next();
        else if (key === "-") prev();
        else if (key === "Enter") handleEnter();
        else if (key === "Backspace") handleBackspace();
        else if (key === "1") toggleEnglish();
        else if (key === "2") toggleChinese();
        else if (key === "3") toggleTest();
        else if (key === " ") speck();
        else if (key.length === 1) addChar(key);

        saveIndex();
    });

    function speck() {
        synthesizer.speak(words[currentIndex].name);
    }

    function next() {
        currentIndex = Math.min(words.length - 1, currentIndex + 1);
        redraw();
    }

    function prev() {
        currentIndex = Math.max(0, currentIndex - 1);
        redraw();
    }

    function redraw() {
        draw();
        renderList();
    }

    function saveIndex() {
        localStorage.setItem("i", currentIndex);
    }

    function handleEnter() {
        const last = mainEl.lastElementChild;
        const input = last.textContent.trim();
        const correct = words[currentIndex].name.trim().toLowerCase();

        if (input) last.style.color = input.toLowerCase() === correct ? "green" : "red";

        if (test && input.toLowerCase() === correct) next();

        mainEl.appendChild(emptyP());
        focusLast();
    }

    function draw() {
        const w = words[currentIndex];
        mainEl.innerHTML = `
        <p>${showEnglish ? w.name : "--"}</p>
        ${showChinese ? w.trans.map(t => `<p>${t}</p>`).join("") : "<p>--</p>"}
        <p>美&nbsp;${w.usphone}&nbsp;&nbsp;/&nbsp;&nbsp;英&nbsp;${w.ukphone}</p>
      `;
        mainEl.appendChild(emptyP());
        focusList();
        clearTimeout(speakT);
        synthesizer.stop();
        synthesizer.speak(w.name);
        let i = 1
        speakT = setInterval(() => {
            i++;
            synthesizer.speak(w.name,{rate:1-(i*0.15)})
            if (i > 2) {
                clearTimeout(speakT);
            }
        }, 2000);
    }

    function emptyP() {
        return document.createElement("p");
    }

    function toggleEnglish() {
        showEnglish = !showEnglish;
        redraw();
    }

    function toggleChinese() {
        showChinese = !showChinese;
        draw();
    }

    function toggleTest() {
        testEl.checked = !testEl.checked;
        test = !test;
    }

    function addChar(k) {
        const p = mainEl.lastElementChild;
        p.textContent += k;
        focusLast();
    }

    function handleBackspace() {
        const items = mainEl.children;
        const last = items[items.length - 1];

        if (items.length < baseLinesCount+2) {
            return;
        }

        if (last.textContent) last.textContent = last.textContent.slice(0, -1);
        else {
            mainEl.removeChild(last);
            focusLast();
        }
    }

    function focusLast() {
        setCursorAt(mainEl.lastElementChild);
    }

    function setCursorAt(p) {
        const range = document.createRange();
        const sel = window.getSelection();
        range.selectNodeContents(p);
        range.collapse(false);
        sel.removeAllRanges();
        sel.addRange(range);
    }

    function focusList() {
        const a = listEl.querySelector("p.active");
        a?.scrollIntoView({behavior: "auto", block: "center"});
    }
</script>
</body>
</html>
